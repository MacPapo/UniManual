#+TITLE: Progetto CPU a singolo ciclo
#+AUTHOR: Jacopo Costantini & Matteo Zambon

* Processore: Datapath & Control
Cerchiamo di progettare un processore MIPS-like semplificato
in grado di eseguire solo:

+ Istruzioni di *memory-reference*: *lw*, *sw*
+ Istruzioni *arithmetic-logic*: *add*, *sub*, *and*, *or*, *slt*
+ Istruzioni di *control-flow*: *beq*, *j*

** Formati delle istruzioni

+ R-type:
  - *op*             =  6 bit
  - *rs*             =  5 bit
  - *rt*             =  5 bit
  - *rd*             =  5 bit
  - *shamt*          =  5 bit
  - *funct*          =  6 bit

+ I-type:
  - *op*             =  6 bit
  - *rs*             =  5 bit
  - *rt*             =  5 bit
  - *immediate*      = 16 bit

+ J-type:
  - *op*             =  6 bit
  - *target address* = 26 bit

*** Fammi spiegare:
+ *op*: codice operativo dell'istruzione
+ *rs, rt, rd*: dei registri sorgente (*rs,rt*) e destinazione (*rd*)
+ *shamt*: shift amount ( è diverso da 0 solo per istruzioni di shift )
+ *funct*: seleziona le varianti dell'operazione specificata in *op*
+ *immediate*: offset dell'indirizzo (load/store) o valore immediato ( op.aritmetiche )
+ *target address*: indirizzo target di un'istruzione di jump

* Passi di progetto

1) Analizzare il set di istruzioni => verificare i requisiti del datapath
   - Il Datapath deve includere gli elementi di memoria corrispondenti ai registri dell'*ISA*
     - Tipicamente sono necessari altri registri, usati internamente o non referenziabili direttamente attraverso l'*ISA* ==> es. *PC( Program counter )*
   - Analizza la semantica di ogni istruzione, data in termini di *trasferimenti dai registri*, ed eventuali *operazioni tra i registri*
     - Il datapath deve fornire i cammini per tutti i *register transfer* necessari, e gli accessi alla memoria
2) Seleziona i vari componenti del datapath (es. ALU) e stabilisci la metodologia di clocking
3) Assembla il datapath in accordo ai requisiti, aggiungendo i segnali di controllo
4) Analizza l'implementazione di ogni istruzione per determinare il *setting* dei segnali di controllo che provocano i vari *register transfer*
5) Assembla la *logica di controllo* in accordo al punto *4*


* Implementazione generica a singolo ciclo

1) Usa il registro *Program Counter* (*PC*), interno alla *CPU*, per fornire alla memoria l'indirizzo dell'istruzione
2) Leggi l'istruzione dalla memoria (*fetch*)
3) Interpreta i campi dell'istruzione per decidere esattamente cosa fare (*decode*)
4) Usa l'*ALU* per l'esecuzione (*execute)
   - *add/sub/and/or/slt* usano l'*ALU* per le operazioni corrispondenti, e il *Register File* per accedere ai registri
   - Le istruzioni di *lw/sw* usano l'*ALU* per calcolare gli indirizzi di memoria
   - L'istruzione di *beq* usa l'*ALU* per controllare l'uguaglianza dei registri
5) Modifica il *PC* e reitera il ciclo

=> l'ALU, il Register File, il PC dovranno far parte del Datapath

* Incremento del PC

Addizionatore aggiuntivo

- Necessario per realizzare, all'interno dello steso ciclo di clock
  + Il *Fetch* dell'istruzione
  + l'incremento del PC

- Non possiamo usare l'ALU principale perchè questa p già utilizzata per eseguire le istruzioni
  + Stiamo implementando una *CPU* a singolo ciclo
    Dove abbiamo risorse *replicate*

- Nota che della memoria istruzioni viene letta una nuova isruzione ad ogni ciclo di clock
  - Il segnale di *MemRead* deve essere sempre *affermato*


* Controllo a singolo ciclo

Il controllo della CPU a singolo ciclo è *combinatorio*
Il *Datapath* è invece sequenziale
- I suoi output dipendono anche dal valore dei registri
  - ES. *ZERO*, oppure l'indirizzo della memoria dati, oppure il valore da immagazzinare in memeoria in conseguenza di una store, dipendono dai valori dello *stato interno del DATAPATH* ( ovvero dal contenuto dei registri )

Dobbiamo attendere che tutti i circuiti siano stabili, sia quelli del datapath che quelli del controllo, prima di attivare il fronte di *salita/discesa* del clock.

Clock in *AND* con i *segnali di controllo di scrittura* ( registri/memoria )
- I valori vengono scritti in corrispondenza del fronte di salita/discesa del clock solo se i segnali relativi sono affermati

Ciclo di clock determinato sulla base del cammino più lungo che i segnali elettrici devono attraversare
- ES: l'istruzione *lw* è quella più costosa:
  + Reg. File(Read)
  + ALU e Adders
  + Mem. Dati
  + Reg. File(Write)
- i circuiti del controllo agiscono in parallelo alla lettura dei registri

* Determiniamo il ciclo di clock per LW

Ipotiziamo i costi in ns per le varie componenti
+ Mem. Istr/Dati: 200 ps
+ Reg. File: 100 ps
+ ALU: 200 ps
+ Control: < 100 ps

Consideriamo l'istruzione *LW*, che abbiamo detto essere la più costosa
- L'unica che usa sia il *Register File in lettura/scrittura* che la *Memoria dati*
- Ciclo di clock lungo 800 ps

* Problemi con il singolo ciclo
Il ciclo singolo e di lunghezza fissa *penalizza le istruzioni veloci*

Anche se complesso, si potrebbe realizzare una CPU a ciclo di clock *variabile*
con i seguenti vantaggi:
+ Istruzioni diverse dalla *LW* eseguite in un tempo < 8 ns, mentre se il ciclo è fisso sarebbero sempre necessari 8 ns

** Controllo ALU
  Dobbiamo definire il circuito che definisce i *4-bit di controllo* dell'ALU (operation) da assegnare in base al
  tipo di istruzione, ovvero basandosi sui campi *op* e *funct*:
  + 0000 operazione di and
  + 0001 operazione di or
  + 0010 operazione di add, lw, sw
  + 0110 operazione di sub e beq
  + 0111 operazione di slt

  Il circuito sarà a due livelli:
  1. 1° livello calcolerà ALUOp (ALUOp0 ALUOp1) in base all'*op* code
  2. 2° livello calcolerà affettivamente Operation in base al campo funct e ALUOp

  Il circuito di 1° livello dovrà semplicemente definire la configurazione dei bit (ALUOp1 ALUOp0) sulla base di op:
  + 00 se lw, sw (Operation=0010) (somma)
  + 01 se beq (Operation=0110) (sottrazione)
  + 10 se arithmetic/logic (Operation dipende dalla specifica istruzione definita dai bit nel funct)

  Definiamo ora la tabella di verità che sulla base di ALUOp e funct determina i 3 bit del controllo dell’ALU:
  + Operation0 = (F3 or F0) and ALUOp1
  + Operation1 = ~F2 or ~ALUOp1
  + Operation2 = (F1 and ALUOp1) or AluOp0
  + Operation3 è sempre a 0




* Ciclo fisso vs variabile
Si consideri di conoscere che in un generico programma, le istruzioni sono combinate in accordo a questo mix:
- 24% *load*
- 12% *store*
- 44% *formato-R*
- 18% *branch*
- 2%  *jump*

Quale è la lunghezza media ( *periodo medio* ) del ciclo di clock nell'implementazione a ciclo variabile?
+ *Periodo medio* = 800 x 24% + 700 x 12% + 600 x 44% + 500 x 18% + 200 x 2% = 630 ps

Le prestazioni della CPU sono calcolabili rispetto a NI ( Numero Istruzioni eseguite da un programma )

- T_var = NI x periodo = NI x 630 ( variabile )
- T_fisso = NI x periodo = NI x 800 ( fisso )

Facendo il rapporto: T_fisso / T_var = 800 / 630 = 1.27

Quindi possiamo dire che l'implementazione a clock variablie è l'1.27 volte più veloce!

Se consideriamo istruzioni più complesse della *LW*, come leistruzioni *FP* di moltiplicazione. l'implementazione a ciclo fisso risulta ulteriormente *penalizzata*

